"
" vimrc
" Settings are divided into groups according to the output of :options
" The number for each section corresponds to the section number of :options
" Most of the help comments beside each option come from :options as well
"

" 2 Moving around, searching and patterns {{{
set incsearch     " show match for partly typed search command
set ignorecase    " ignore case when using a search pattern
set smartcase     " override 'ignorecase' when pattern has upper case characters
" }}}

" 4 Displaying text {{{
set scrolloff=3   " number of screen lines to show around the cursor
set linebreak     " wrap long lines at a character in 'breakat'
set lazyredraw    " don't redraw while executing macros
" }}}

" 5 Syntax, highlighting and spelling {{{
filetype plugin on    " enable loading filetype plugins
filetype indent on    " enable loading filetype indent files
syntax enable         " enable syntax highlighting
set hlsearch          " highlight all matches for the last used search pattern
if version >= 700     " map spell check
    noremap <leader>sp :set spell!<CR>
endif
" }}}

" 6 Multiple windows {{{
set laststatus=2      " 0, 1 or 2; when to use a status line for the last window
set hidden            " don't unload a buffer when no longer shown in a window
" }}}

" 11 Messages and info {{{
set ruler             " show cursor position below each window
set showcmd           " show (partial) command keys in the status line
" }}}

" 13 Editing text {{{
"set showmatch         " when inserting a bracket, briefly jump to its match
" }}}

" 14 Tabs and indenting {{{
set tabstop=4         " number of spaces a <Tab> in the text stands for
set shiftwidth=4      " number of spaces used for each step of (auto)indent
set smarttab          " a <Tab> in an indent inserts 'shiftwidth' spaces
set softtabstop=4     " if non-zero, number of spaces to insert for a <Tab>
set shiftround        " round to 'shiftwidth' for "<<" and ">>"
set expandtab         " expand <Tab> to spaces in Insert mode
set autoindent        " automatically set the indent of a new line
set smartindent       " do clever autoindenting
" }}}

" 15 Folding {{{
"set nofoldenable
" }}}

" 20 Command line editing {{{
set wildmenu        " command-line completion shows a list of matches
" }}}

" Newline mappings {{{
" insert new lines and stay in normal mode
nnoremap <silent> zj o<Esc>
nnoremap <silent> zk O<Esc>
" }}}

" Vimscript file settings {{{
augroup filetype_vim
    " enable folding based on markers for vimscript files
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}

" Pathogen settings {{{
runtime bundle/vim-pathogen/autoload/pathogen.vim
call pathogen#runtime_append_all_bundles()
call pathogen#helptags()
" }}}

" Colorscheme settings {{{
set t_Co=256                " enable 256 color terminal mode
colorscheme jellybeans
" }}}

" Generic leader mappings {{{
" toggle paste mode
set pastetoggle=<leader>\p

" clear the highlighting for the last search
nnoremap <silent><leader>h :nohlsearch<cr>

" automatically prepend very-magic search mode to all searches
nnoremap / /\v

" Quick-fix mappings {{{
" returns 1 if the quickfix window is open, 0 otherwise
function! IsQuickfixOpen()
    for i in range(1, winnr('$'))
        if getbufvar(winbufnr(i), '&buftype') == 'quickfix'
            return 1
        endif
    endfor
endfunction

" Jumps to the next/prev buffer or quickfix item, depending on if the quickfix
" buffer is currently displayed or not
" direction: one of "next" or "previous"
function! GotoQuickfixOrBuffer(direction)
    if IsQuickfixOpen()
        let type = "c"
    else
        let type = "b"
    endif
    silent! execute "normal! :" . type . a:direction . "\<cr>"
endfunction

" use \[ and \] to move backward/forward between the error list or buffers,
" when appropriate
nnoremap <silent><leader>[ :call GotoQuickfixOrBuffer("previous")<cr>
nnoremap <silent><leader>] :call GotoQuickfixOrBuffer("next")<cr>
" use \' to switch back and forth between last opened buffer
nnoremap <silent><leader>' <c-^>

" Toggle quick-fix {{{
nnoremap <silent><leader>q :call QuickfixToggle()<cr>

function! QuickfixToggle()
    if IsQuickfixOpen()
        cclose
        if exists("g:quickfix_return_to_window")
            execute g:quickfix_return_to_window . "wincmd w"
        endif
    else
        let g:quickfix_return_to_window = winnr()
        copen
    endif
endfunction
" }}}

" }}}

" problem with arrows in NERDTree ?
" try this:
" http://stackoverflow.com/questions/3766204/vim-doesnt-support-unicode
nnoremap <leader>f :NERDTreeToggle<cr>

" toggle alternate file (switches from .h to .c/cpp/etc)
nnoremap <leader>a :A<cr>
" }}}

" Restore cursor postion {{{
" uses mkview to restore folds/cursor/etc. for appropriate buffers only
let g:skipview_files = []
function! MakeViewCheck()
    if has('quickfix') && &buftype =~ 'nofile'
        return 0        " Buffer is marked as not a file
    elseif empty(glob(expand('%:p')))
        return 0        " File does not exist on disk
    elseif len($TEMP) && expand('%:p:h') == $TEMP
        return 0        " We're in a temp dir
    elseif len($TMP) && expand('%:p:h') == $TMP
        return 0        " Also in temp dir
    elseif index(g:skipview_files, expand('%')) >= 0
        return 0        " File is in skip list
    endif
    return 1
endfunction

augroup restore_cursor
    autocmd!
    au BufWritePost,BufLeave,BufWinLeave ?* if MakeViewCheck() | mkview | endif
    au BufWinEnter ?* if MakeViewCheck() | silent loadview | endif
augroup END

" only save folds/cursor info for views, not local mappings, etc.
set viewoptions=folds,cursor,slash,unix
" }}}

" Vimwiki settings {{{
" turn off auto formatting so that TAB still works for snippets
let g:vimwiki_table_auto_fmt = 0
let g:vimwiki_table_mappings = 0
" automatically export to HTML on save
let g:vimwiki_list = [{'path': '~/vimwiki/', 'auto_export': 1}]
" }}}

" Supertab settings {{{
let g:SuperTabDefaultCompletionType = "context"
" }}}

" cscope settings {{{
if has("cscope")
    set cscopetag           " always search cscope databases and tag files
    set csto=1              " prefer ctags first

    " add any database in current directory
    if filereadable("cscope.out")
        cs add cscope.out
    " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
    set cscopeverbose       " show a message when any other cscope db is added

    " Cscope actions:
    " s: Find this C symbol
    " g: Find this definition
    " d: Find functions called by this function
    " c: Find functions calling this function
    " t: Find this text string
    " e: Find this egrep pattern
    " f: Find this file
    " i: Find files #including this file
    nnoremap <leader>cs :cs find s <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>cg :cs find g <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>cc :cs find c <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>ct :cs find t <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>ce :cs find e <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>cf :cs find f <C-R>=expand("<cfile>")<CR><CR>
    nnoremap <leader>ci :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nnoremap <leader>cd :cs find d <C-R>=expand("<cword>")<CR><CR>
endif
" }}}

" Unlimited undo {{{
if exists("+undofile")
    set undofile                " save undo history to a file
    set undodir=~/.vimundo      " directory to save undo files in
endif
" }}}

" Tagbar settings {{{
nnoremap <silent><leader>t :TagbarToggle<CR>
let g:tagbar_autoclose = 1
let g:tagbar_autofocus = 1
let g:tagbar_autoshowtag = 1
" }}}
